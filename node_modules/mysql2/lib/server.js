const express = require('express');
const http = require('http');
const cors = require('cors');
const mysql = require('mysql2/promise');
const path = require('path');

// 讀取環境變數（.env 與 emtionre-main.env）
require('dotenv').config({ path: path.resolve(__dirname, '.env') });
require('dotenv').config({ path: path.resolve(__dirname, 'emtionre-main.env') });

// 建立 Express
const app = express();
const CORS_ORIGIN = process.env.CORS_ORIGIN || 'http://localhost:5173';
app.use(cors({ origin: CORS_ORIGIN }));
app.use(express.json());

// 建立 MySQL Pool
const pool = mysql.createPool({
  host: process.env.DB_HOST || '127.0.0.1',
  port: parseInt(process.env.DB_PORT || '3306', 10),
  user: process.env.DB_USER || 'root',
  password: process.env.DB_PASS || '',
  database: process.env.DB_NAME || 'emotion',
  waitForConnections: true,
  connectionLimit: 10
});

// 啟動時測試 DB 連線
(async () => {
  try {
    const conn = await pool.getConnection();
    await conn.ping();
    conn.release();
    console.log('MySQL connected');
  } catch (err) {
    console.error('MySQL connection failed:', err.message);
  }
})();

/* ==== 情緒推導滿意度 0~100，基準 50 ==== */
const POS_WEIGHTS = { happiness: 1.0, surprise: 0.4 };
const NEG_WEIGHTS = { sadness: 0.8, anger: 1.0, disgust: 0.9, fear: 0.9 };
// neutral 不影響

function norm01(v) {
  if (v == null) return 0;
  const n = Number(v);
  if (!Number.isFinite(n)) return 0;
  const x = n > 1 ? n / 100 : n; // 支援 0~1 或 0~100
  return Math.max(0, Math.min(1, x));
}

function deriveSatisfaction(row) {
  const p = POS_WEIGHTS.happiness * norm01(row.happiness)
          + POS_WEIGHTS.surprise  * norm01(row.surprise);
  const n = NEG_WEIGHTS.sadness * norm01(row.sadness)
          + NEG_WEIGHTS.anger   * norm01(row.anger)
          + NEG_WEIGHTS.disgust * norm01(row.disgust)
          + NEG_WEIGHTS.fear    * norm01(row.fear);
  const score = 50 + 50 * (p - n);
  return Math.max(0, Math.min(100, score));
}

/* ==== API：當日資料切段，每分鐘為一筆，超過 60 秒空檔即斷段 ====
   GET /api/satisfaction-segments?date=YYYY-MM-DD
   回傳：
   {
     date,
     first_minute: 'YYYY-MM-DD HH:mm:00' | null,
     overall_avg: number|null,
     segments: [
       {
         start: 'YYYY-MM-DD HH:mm:00',
         end:   'YYYY-MM-DD HH:mm:00',
         count: number,
         points: [ { minute: 'YYYY-MM-DD HH:mm:00', value: number } ]
       }, ...
     ]
   }
*/
app.get('/api/satisfaction-segments', async (req, res) => {
  try {
    const date = String(req.query.date || '').trim();
    if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
      return res.status(400).json({ error: 'invalid date, expected YYYY-MM-DD' });
    }

    const table = process.env.DB_TABLE || 'emotion_detection_customeremotion';
    const dateCol = process.env.DB_DATE_COLUMN || 'created_at';

    // 避免使用 DATE() 造成索引失效
    const start = `${date} 00:00:00`;
    const next  = `${date} 00:00:00`;

    // 撈當日資料並在 SQL 層先對齊分鐘
    const [rows] = await pool.query(
      `
      SELECT
        DATE_FORMAT(\`${dateCol}\`, '%Y-%m-%d %H:%i:00') AS minute,
        happiness, sadness, anger, surprise, disgust, fear, neutral
      FROM \`${table}\`
      WHERE \`${dateCol}\` >= ?
        AND \`${dateCol}\` < DATE_ADD(?, INTERVAL 1 DAY)
      ORDER BY \`${dateCol}\` ASC
      `,
      [start, next]
    );

    if (!rows.length) {
      return res.json({ date, first_minute: null, overall_avg: null, segments: [] });
    }

    // 同一分鐘內平均
    const perMinute = new Map(); // minute -> { sum, cnt }
    let totalSum = 0, totalCnt = 0;
    for (const r of rows) {
      const s = deriveSatisfaction(r);
      if (!perMinute.has(r.minute)) perMinute.set(r.minute, { sum: 0, cnt: 0 });
      const cell = perMinute.get(r.minute);
      cell.sum += s; cell.cnt += 1;
      totalSum += s; totalCnt += 1;
    }

    const minutes = [...perMinute.entries()]
      .map(([minute, { sum, cnt }]) => ({ minute, value: Number((sum / cnt).toFixed(6)) }))
      .sort((a, b) => a.minute.localeCompare(b.minute));

    // 分段：相鄰分鐘差 > 60 秒就斷
    const parseMinute = (m) => {
      const [d, t] = m.split(' ');
      const [Y, M, D] = d.split('-').map(Number);
      const [h, mi, s] = t.split(':').map(Number);
      return new Date(Y, M - 1, D, h, mi, s || 0, 0);
    };

    const segments = [];
    let current = null;
    for (let i = 0; i < minutes.length; i++) {
      const cur = minutes[i];
      const curTs = parseMinute(cur.minute).getTime();
      if (!current) {
        current = { start: cur.minute, end: cur.minute, points: [cur] };
        continue;
      }
      const prev = current.points[current.points.length - 1];
      const prevTs = parseMinute(prev.minute).getTime();
      const diffSec = Math.floor((curTs - prevTs) / 1000);

      if (diffSec > 60) {
        current.end = current.points[current.points.length - 1].minute;
        current.count = current.points.length;
        segments.push(current);
        current = { start: cur.minute, end: cur.minute, points: [cur] };
      } else {
        current.points.push(cur);
      }
    }
    if (current) {
      current.end = current.points[current.points.length - 1].minute;
      current.count = current.points.length;
      segments.push(current);
    }

    const first_minute = segments.length ? segments[0].start : null;
    const overall_avg = totalCnt ? Number((totalSum / totalCnt).toFixed(6)) : null;

    res.json({ date, first_minute, overall_avg, segments });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'DB error' });
  }
});
app.get('/api/minute-satisfaction', async (req, res) => {
  try {
    const date = String(req.query.date || '').trim();
    const time = String(req.query.time || '').trim();
    if (!/^\d{4}-\d{2}-\d{2}$/.test(date) || !/^\d{2}:\d{2}$/.test(time)) {
      return res.status(400).json({ error: 'date=YYYY-MM-DD, time=HH:mm required' });
    }

    const start = `${date} ${time}:00`;
    const table = process.env.DB_TABLE || 'emotion_detection_customeremotion';
    const dateCol = process.env.DB_DATE_COLUMN || 'created_at';

    const [rows] = await pool.query(
      `
      SELECT
        DATE_FORMAT(\`${dateCol}\`, '%Y-%m-%d %H:%i:%s') AS second_mark,
        happiness, sadness, anger, surprise, disgust, fear
      FROM \`${table}\`
      WHERE \`${dateCol}\` >= ?
        AND \`${dateCol}\` < DATE_ADD(?, INTERVAL 1 MINUTE)
      ORDER BY \`${dateCol}\`
      `,
      [start, start]
    );

    if (!rows.length) {
      return res.json({ start, durationSec: 60, avg: null, points: [] });
    }

    const buckets = new Map();
    rows.forEach((row) => {
      const score = deriveSatisfaction(row);
      if (!buckets.has(row.second_mark)) buckets.set(row.second_mark, { sum: 0, count: 0 });
      const cell = buckets.get(row.second_mark);
      cell.sum += score;
      cell.count += 1;
    });

    const startDate = new Date(start);
    const points = [];
    for (let i = 0; i < 60; i += 1) {
      const ts = new Date(startDate.getTime() + i * 1000);
      const label = ts.toISOString().slice(0, 19).replace('T', ' ');
      const bucket = buckets.get(label);
      points.push({
        second: i,
        timestamp: label,
        value: bucket ? Number((bucket.sum / bucket.count).toFixed(4)) : null
      });
    }

    const values = points.map((p) => p.value).filter((v) => typeof v === 'number');
    const avg = values.length ? values.reduce((sum, v) => sum + v, 0) / values.length : null;

    res.json({ start, durationSec: 60, avg, points });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'DB error' });
  }
});

/* 列出近幾天有資料的日期（預設 30 天） */
app.get('/api/available-dates', async (req, res) => {
  try {
    const table = process.env.DB_TABLE || 'emotion_detection_customeremotion';
    const dateCol = process.env.DB_DATE_COLUMN || 'created_at';
    const limit = Math.min(
      Math.max(parseInt(String(req.query.limit || '30'), 10) || 30, 1),
      365
    );
    const [rows] = await pool.query(
      `
      SELECT DATE(\`${dateCol}\`) AS d, COUNT(*) AS c
      FROM \`${table}\`
      GROUP BY DATE(\`${dateCol}\`)
      ORDER BY DATE(\`${dateCol}\`) DESC
      LIMIT ?
      `,
      [limit]
    );
    res.json({ dates: rows.map(r => ({ date: r.d, count: Number(r.c) })) });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'DB error' });
  }
});

// 健康檢查
app.get('/health', (_req, res) => res.json({ ok: true }));
app.get('/db-ping', async (_req, res) => {
  try {
    const c = await pool.getConnection();
    await c.ping();
    c.release();
    res.json({ db: 'ok' });
  } catch (e) {
    res.status(500).json({ db: 'fail', error: e.message });
  }
});

// 啟動
const server = http.createServer(app);
const PORT = parseInt(process.env.PORT || '4000', 10);
server.listen(PORT, () => console.log(`API running on http://localhost:${PORT}`));

// 關閉
async function shutdown() {
  console.log('Shutting down...');
  try { await pool.end(); } catch (e) {}
  process.exit(0);
}
process.on('SIGINT', shutdown);
process.on('SIGTERM', shutdown);
